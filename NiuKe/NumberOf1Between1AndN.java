package NiuKe;

/**
 * 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
 * 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。
 * ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。
 *
 * 思路：
 * 从数字的特点上考虑，
 * 1-10，个位数上数字X出现的次数为1
 * 1-100，十位上数字X出现的次数为10
 * 1-1000，百位上数字X出现的次数为100
 *
 * 举个例子：数字从1-2593，求数5出现的次数，可得总计出现了 813 次，其中有 259 次出现在个位，260 次出现在十位，294 次出现在百位，0 次出现在千位
 * 从个位出现的次数分析，1到2590，共有259个10，所以任意的X会出现259次，剩下三个数2591, 2592 和 2593，末尾都小于5，所以不会包含5
 * 从十位出现的次数分析，1到2500，共有25个100，所以任意的X会出现250次，剩下的数字是2501到2593，最大的十位数大于X，因此会包含10个5，总共250+10=260次
 * 接着是百位，共有2个1000，所以任意的X会出现200次，剩下的数字是2001-2593，最大的百位为5，所以共有93+1=94次，因而总共有294次
 * 最后是千位，由于没有更高位，直接看千位数字最大为2，小于5，所以出现0次
 *
 * 对于1-9的数字都可以使用这种方法，但是对为0的情况需要加个条件，因为第一位不可能为0，即不存在01、02、03等情况
 * 比如102，看0出现的次数，到达百位的时候，即最高位的时候，百位不可能取0，因而此时不能加入结果计数
 */

public class NumberOf1Between1AndN {

    public int NumberOf1Between1AndN_Solution(int n)
    {
        int res = 0, k;     //k表示包括倒数第i位前面的数字

        for (int i = 1; (k = n/i) != 0; i *= 10)
        {
            res += (k/10) * i;          //k/10表示前面的位的数字

            int cur = k % 10;           //取得当前位
            if (cur > 1)
            {
                res += i;
            }else if (cur == 1)
            {
                res += n - k * i + 1;
            }
        }

        return res;
    }

    public static void main(String[] args)
    {
        System.out.println(new NumberOf1Between1AndN().NumberOf1Between1AndN_Solution(13));
    }

}
